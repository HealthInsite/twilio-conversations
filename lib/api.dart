// Autogenerated from Pigeon (v1.0.6), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/foundation.dart' show WriteBuffer, ReadBuffer;
import 'package:flutter/services.dart';

class ConversationClientData {
  String? myIdentity;
  String? connectionState;
  bool? isReachabilityEnabled;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['myIdentity'] = myIdentity;
    pigeonMap['connectionState'] = connectionState;
    pigeonMap['isReachabilityEnabled'] = isReachabilityEnabled;
    return pigeonMap;
  }

  static ConversationClientData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConversationClientData()
      ..myIdentity = pigeonMap['myIdentity'] as String?
      ..connectionState = pigeonMap['connectionState'] as String?
      ..isReachabilityEnabled = pigeonMap['isReachabilityEnabled'] as bool?;
  }
}

class ConversationData {
  String? sid;
  AttributesData? attributes;
  String? uniqueName;
  String? friendlyName;
  String? status;
  String? synchronizationStatus;
  String? dateCreated;
  String? createdBy;
  String? dateUpdated;
  String? lastMessageDate;
  int? lastReadMessageIndex;
  int? lastMessageIndex;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['uniqueName'] = uniqueName;
    pigeonMap['friendlyName'] = friendlyName;
    pigeonMap['status'] = status;
    pigeonMap['synchronizationStatus'] = synchronizationStatus;
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['createdBy'] = createdBy;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['lastMessageDate'] = lastMessageDate;
    pigeonMap['lastReadMessageIndex'] = lastReadMessageIndex;
    pigeonMap['lastMessageIndex'] = lastMessageIndex;
    return pigeonMap;
  }

  static ConversationData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConversationData()
      ..sid = pigeonMap['sid'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null
      ..uniqueName = pigeonMap['uniqueName'] as String?
      ..friendlyName = pigeonMap['friendlyName'] as String?
      ..status = pigeonMap['status'] as String?
      ..synchronizationStatus = pigeonMap['synchronizationStatus'] as String?
      ..dateCreated = pigeonMap['dateCreated'] as String?
      ..createdBy = pigeonMap['createdBy'] as String?
      ..dateUpdated = pigeonMap['dateUpdated'] as String?
      ..lastMessageDate = pigeonMap['lastMessageDate'] as String?
      ..lastReadMessageIndex = pigeonMap['lastReadMessageIndex'] as int?
      ..lastMessageIndex = pigeonMap['lastMessageIndex'] as int?;
  }
}

class AttributesData {
  String? type;
  String? data;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['type'] = type;
    pigeonMap['data'] = data;
    return pigeonMap;
  }

  static AttributesData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return AttributesData()
      ..type = pigeonMap['type'] as String?
      ..data = pigeonMap['data'] as String?;
  }
}

class TokenData {
  String? token;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['token'] = token;
    return pigeonMap;
  }

  static TokenData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TokenData()
      ..token = pigeonMap['token'] as String?;
  }
}

class MessageMediaData {
  String? sid;
  String? fileName;
  String? type;
  int? size;
  String? conversationSid;
  String? messageSid;
  int? messageIndex;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['fileName'] = fileName;
    pigeonMap['type'] = type;
    pigeonMap['size'] = size;
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['messageSid'] = messageSid;
    pigeonMap['messageIndex'] = messageIndex;
    return pigeonMap;
  }

  static MessageMediaData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageMediaData()
      ..sid = pigeonMap['sid'] as String?
      ..fileName = pigeonMap['fileName'] as String?
      ..type = pigeonMap['type'] as String?
      ..size = pigeonMap['size'] as int?
      ..conversationSid = pigeonMap['conversationSid'] as String?
      ..messageSid = pigeonMap['messageSid'] as String?
      ..messageIndex = pigeonMap['messageIndex'] as int?;
  }
}

class MessageData {
  String? sid;
  int? messageIndex;
  String? author;
  String? subject;
  String? messageBody;
  String? type;
  bool? hasMedia;
  MessageMediaData? media;
  String? conversationSid;
  String? participantSid;
  String? dateCreated;
  String? dateUpdated;
  String? lastUpdatedBy;
  AttributesData? attributes;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['messageIndex'] = messageIndex;
    pigeonMap['author'] = author;
    pigeonMap['subject'] = subject;
    pigeonMap['messageBody'] = messageBody;
    pigeonMap['type'] = type;
    pigeonMap['hasMedia'] = hasMedia;
    pigeonMap['media'] = media == null ? null : media!.encode();
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['participantSid'] = participantSid;
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['lastUpdatedBy'] = lastUpdatedBy;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    return pigeonMap;
  }

  static MessageData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageData()
      ..sid = pigeonMap['sid'] as String?
      ..messageIndex = pigeonMap['messageIndex'] as int?
      ..author = pigeonMap['author'] as String?
      ..subject = pigeonMap['subject'] as String?
      ..messageBody = pigeonMap['messageBody'] as String?
      ..type = pigeonMap['type'] as String?
      ..hasMedia = pigeonMap['hasMedia'] as bool?
      ..media = pigeonMap['media'] != null
          ? MessageMediaData.decode(pigeonMap['media']!)
          : null
      ..conversationSid = pigeonMap['conversationSid'] as String?
      ..participantSid = pigeonMap['participantSid'] as String?
      ..dateCreated = pigeonMap['dateCreated'] as String?
      ..dateUpdated = pigeonMap['dateUpdated'] as String?
      ..lastUpdatedBy = pigeonMap['lastUpdatedBy'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null;
  }
}

class MessageOptionsData {
  String? body;
  AttributesData? attributes;
  String? mimeType;
  String? filename;
  String? inputPath;
  int? mediaProgressListenerId;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['body'] = body;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['mimeType'] = mimeType;
    pigeonMap['filename'] = filename;
    pigeonMap['inputPath'] = inputPath;
    pigeonMap['mediaProgressListenerId'] = mediaProgressListenerId;
    return pigeonMap;
  }

  static MessageOptionsData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageOptionsData()
      ..body = pigeonMap['body'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null
      ..mimeType = pigeonMap['mimeType'] as String?
      ..filename = pigeonMap['filename'] as String?
      ..inputPath = pigeonMap['inputPath'] as String?
      ..mediaProgressListenerId = pigeonMap['mediaProgressListenerId'] as int?;
  }
}

class ParticipantData {
  String? sid;
  String? conversationSid;
  String? type;
  AttributesData? attributes;
  String? dateCreated;
  String? dateUpdated;
  String? identity;
  int? lastReadMessageIndex;
  String? lastReadTimestamp;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['type'] = type;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['identity'] = identity;
    pigeonMap['lastReadMessageIndex'] = lastReadMessageIndex;
    pigeonMap['lastReadTimestamp'] = lastReadTimestamp;
    return pigeonMap;
  }

  static ParticipantData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ParticipantData()
      ..sid = pigeonMap['sid'] as String?
      ..conversationSid = pigeonMap['conversationSid'] as String?
      ..type = pigeonMap['type'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null
      ..dateCreated = pigeonMap['dateCreated'] as String?
      ..dateUpdated = pigeonMap['dateUpdated'] as String?
      ..identity = pigeonMap['identity'] as String?
      ..lastReadMessageIndex = pigeonMap['lastReadMessageIndex'] as int?
      ..lastReadTimestamp = pigeonMap['lastReadTimestamp'] as String?;
  }
}

class UserData {
  String? identity;
  AttributesData? attributes;
  String? friendlyName;
  bool? isNotifiable;
  bool? isOnline;
  bool? isSubscribed;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['identity'] = identity;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['friendlyName'] = friendlyName;
    pigeonMap['isNotifiable'] = isNotifiable;
    pigeonMap['isOnline'] = isOnline;
    pigeonMap['isSubscribed'] = isSubscribed;
    return pigeonMap;
  }

  static UserData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return UserData()
      ..identity = pigeonMap['identity'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null
      ..friendlyName = pigeonMap['friendlyName'] as String?
      ..isNotifiable = pigeonMap['isNotifiable'] as bool?
      ..isOnline = pigeonMap['isOnline'] as bool?
      ..isSubscribed = pigeonMap['isSubscribed'] as bool?;
  }
}

class MessageCount {
  int? count;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['count'] = count;
    return pigeonMap;
  }

  static MessageCount decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageCount()
      ..count = pigeonMap['count'] as int?;
  }
}

class MessageIndex {
  int? index;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['index'] = index;
    return pigeonMap;
  }

  static MessageIndex decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageIndex()
      ..index = pigeonMap['index'] as int?;
  }
}

class _PluginApiCodec extends StandardMessageCodec {
  const _PluginApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ConversationClientData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ConversationClientData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class PluginApi {
  /// Constructor for [PluginApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PluginApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PluginApiCodec();

  Future<void> debug(bool arg_enableNative, bool arg_enableSdk) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PluginApi.debug', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_enableNative, arg_enableSdk]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<ConversationClientData> create(String arg_jwtToken) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PluginApi.create', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_jwtToken]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ConversationClientData?)!;
    }
  }
}

class _ConversationClientApiCodec extends StandardMessageCodec {
  const _ConversationClientApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ConversationData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is TokenData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ConversationData.decode(readValue(buffer)!);
      
      case 129:       
        return TokenData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class ConversationClientApi {
  /// Constructor for [ConversationClientApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ConversationClientApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ConversationClientApiCodec();

  Future<void> updateToken(String arg_token) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.updateToken', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_token]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> shutdown() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.shutdown', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<ConversationData> createConversation(String arg_friendlyName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.createConversation', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_friendlyName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ConversationData?)!;
    }
  }

  Future<List<ConversationData?>> getMyConversations() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.getMyConversations', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<ConversationData?>();
    }
  }

  Future<ConversationData> getConversation(String arg_conversationSidOrUniqueName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.getConversation', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSidOrUniqueName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ConversationData?)!;
    }
  }

  Future<void> registerForNotification(TokenData arg_tokenData) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.registerForNotification', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_tokenData]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> unregisterForNotification(TokenData arg_tokenData) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.unregisterForNotification', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_tokenData]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _ConversationApiCodec extends StandardMessageCodec {
  const _ConversationApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is MessageCount) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageIndex) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageOptionsData) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is ParticipantData) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return MessageCount.decode(readValue(buffer)!);
      
      case 129:       
        return MessageData.decode(readValue(buffer)!);
      
      case 130:       
        return MessageIndex.decode(readValue(buffer)!);
      
      case 131:       
        return MessageOptionsData.decode(readValue(buffer)!);
      
      case 132:       
        return ParticipantData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class ConversationApi {
  /// Constructor for [ConversationApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ConversationApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ConversationApiCodec();

  Future<bool> join(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.join', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<bool> leave(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.leave', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<void> destroy(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.destroy', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> typing(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.typing', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<MessageData> sendMessage(String arg_conversationSid, MessageOptionsData arg_options) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.sendMessage', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_options]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageData?)!;
    }
  }

  Future<bool> addParticipantByIdentity(String arg_conversationSid, String arg_identity) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.addParticipantByIdentity', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_identity]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<bool> removeParticipantByIdentity(String arg_conversationSid, String arg_identity) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.removeParticipantByIdentity', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_identity]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<List<ParticipantData?>> getParticipantsList(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantsList', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<ParticipantData?>();
    }
  }

  Future<MessageCount> getMessagesCount(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessagesCount', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<MessageCount> getUnreadMessagesCount(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getUnreadMessagesCount', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<MessageIndex> setLastReadMessageIndex(String arg_conversationSid, int arg_lastReadMessageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setLastReadMessageIndex', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_lastReadMessageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageIndex?)!;
    }
  }

  Future<MessageIndex> setAllMessagesRead(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setAllMessagesRead', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageIndex?)!;
    }
  }

  Future<List<MessageData?>> getMessagesBefore(String arg_conversationSid, int arg_index, int arg_count) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessagesBefore', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_index, arg_count]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<MessageData?>();
    }
  }

  Future<List<MessageData?>> getLastMessages(String arg_conversationSid, int arg_count) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getLastMessages', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_count]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<MessageData?>();
    }
  }

  Future<String> setFriendlyName(String arg_conversationSid, String arg_friendlyName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setFriendlyName', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_friendlyName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }
}

class _ParticipantApiCodec extends StandardMessageCodec {
  const _ParticipantApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is UserData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return UserData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class ParticipantApi {
  /// Constructor for [ParticipantApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ParticipantApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ParticipantApiCodec();

  Future<UserData> getUser(String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ParticipantApi.getUser', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as UserData?)!;
    }
  }
}

class _MessageApiCodec extends StandardMessageCodec {
  const _MessageApiCodec();
}

class MessageApi {
  /// Constructor for [MessageApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MessageApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _MessageApiCodec();

  Future<String> getMediaContentTemporaryUrl(String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.getMediaContentTemporaryUrl', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }
}
